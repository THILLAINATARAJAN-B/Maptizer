// ✅ Essential Node.js modules
const fs = require('fs');
const path = require('path');


// ✅ Service imports
const qlooService = require('../services/qlooService');
const geoService = require('../services/geoService');
const summaryService = require('../services/summaryService');
const pdfService = require('../services/pdfService');

// ✅ Utility imports
const logger = require('../utils/logger');
const dataManager = require('../utils/dataManager');
const errorFormatter = require('../utils/errorFormatter');

// ✅ Helper functions outside the class (fixes the calculateIntensity error)
function aggregateZScores(demographicsList) {
  logger.info('Aggregating Z-scores for demographics data');
  
  const ageSum = {};
  const ageCount = {};
  const genderSum = {};
  const genderCount = {};

  demographicsList.forEach(demo => {
    if (!demo) return;
    const { age = {}, gender = {} } = demo.query || {};

    Object.entries(age).forEach(([k, v]) => {
      if (typeof v === 'number') {
        ageSum[k] = (ageSum[k] || 0) + v;
        ageCount[k] = (ageCount[k] || 0) + 1;
      }
    });

    Object.entries(gender).forEach(([k, v]) => {
      if (typeof v === 'number') {
        genderSum[k] = (genderSum[k] || 0) + v;
        genderCount[k] = (genderCount[k] || 0) + 1;
      }
    });
  });

  const aggregatedAgeScores = {};
  Object.entries(ageSum).forEach(([k, total]) => {
    aggregatedAgeScores[k] = total / (ageCount[k] || 1);
  });

  const aggregatedGenderScores = {};
  Object.entries(genderSum).forEach(([k, total]) => {
    aggregatedGenderScores[k] = total / (genderCount[k] || 1);
  });

  logger.info('Z-scores aggregated successfully', {
    ageScores: Object.keys(aggregatedAgeScores).length,
    genderScores: Object.keys(aggregatedGenderScores).length
  });

  return { aggregatedAgeScores, aggregatedGenderScores };
}

function calculateIntensity(query) {
  if (!query) return 0.5;
  const affinity = query.affinity || 0.5;
  const affinityRank = query.affinity_rank || 0.5;
  const popularity = query.popularity || 0.5;
  return (affinity * 0.4 + affinityRank * 0.3 + popularity * 0.3);
}

function getMostCommonCategory(data) {
  const categories = data.map(p => p.location?.category || 'general');
  const counts = {};
  categories.forEach(cat => {
    counts[cat] = (counts[cat] || 0) + 1;
  });
  return Object.keys(counts).sort((a, b) => counts[b] - counts[a])[0] || 'general';
}

function calculateCoverageArea(data) {
  if (data.length === 0) return 0;
  const lats = data.map(p => p.location?.latitude).filter(lat => lat != null);
  const lngs = data.map(p => p.location?.longitude).filter(lng => lng != null);
  if (lats.length === 0 || lngs.length === 0) return 0;
  
  const latRange = Math.max(...lats) - Math.min(...lats);
  const lngRange = Math.max(...lngs) - Math.min(...lngs);
  return (latRange * lngRange * 111 * 111).toFixed(2); // Rough km² calculation
}

class MainController {
  // ✅ Search functionality
  async search(req, res) {
    const startTime = Date.now();
    logger.info('Search request initiated', { body: req.body });

    try {
      let { query, lat, long, radius = 100, page = 1, take = 20 } = req.body;

      if (!query || !lat || !long) {
        logger.error('Missing required parameters for search', { query, lat, long });
        return res.status(400).json({ error: 'Query, Latitude, and Longitude are required' });
      }

      const maxRadius = 100;
      radius = Number(radius);
      if (isNaN(radius) || radius <= 0 || radius > maxRadius) radius = maxRadius;

      logger.info('Calling Qloo search service', { query, lat, long, radius, page, take });
      const searchResponse = await qlooService.searchPlaces({
        query, lat, long, radius, page, take
      });

      // Save search response to data
      dataManager.saveApiResponse('search', searchResponse, { query, lat, long, radius });

      const results = searchResponse.results || [];
      const entityIds = results.map(item => item.entity_id).filter(Boolean);
      
      logger.info('Search completed, fetching demographics', { 
        resultCount: results.length, 
        entityIds: entityIds.length 
      });

      const fetchDemographics = async (entity_id) => {
        const cached = dataManager.getCachedDemographics(entity_id);
        if (cached) {
          logger.info('Using cached demographics', { entity_id });
          return cached;
        }

        try {
          logger.info('Fetching demographics from API', { entity_id });
          const demoData = await qlooService.getDemographics(entity_id);
          dataManager.saveDemographics(entity_id, demoData);
          return demoData;
        } catch (error) {
          logger.error('Failed to fetch demographics', { entity_id, error: error.message });
          return null;
        }
      };

      const demographicsResults = await Promise.all(entityIds.map(fetchDemographics));
      const enrichedResults = results.map((item, i) => ({
        ...item,
        demographics: demographicsResults[i] || null,
      }));

      // ✅ Fixed: Call the standalone function
      const { aggregatedAgeScores, aggregatedGenderScores } = aggregateZScores(demographicsResults);

      const responseData = {
        items: enrichedResults,
        aggregatedAgeScores,
        aggregatedGenderScores,
      };

      // Save final response
      dataManager.saveApiResponse('search_final', responseData, { query, lat, long });

      logger.info('Search request completed', { 
        duration: Date.now() - startTime,
        itemsCount: enrichedResults.length
      });

      res.json(responseData);

    } catch (error) {
      logger.error('Search request failed', { error: error.message, stack: error.stack });
      res.status(500).json(errorFormatter.formatError('Failed to fetch data', error));
    }
  }

  // ✅ Generate summary functionality
  async generateSummary(req, res) {
    const startTime = Date.now();
    logger.info('Generate summary request initiated', { body: req.body });

    const { tags } = req.body;

    if (!tags) {
      return res.status(400).json({ 
        success: false, 
        message: 'Tags data is required for summary generation' 
      });
    }

    try {
      logger.info('Calling GROQ summary service', { tagsCount: tags?.length });
      const summary = await summaryService.generateSummary(tags);
      
      dataManager.saveApiResponse('summary', { summary, tags }, { tagsCount: tags?.length });

      logger.info('Generate summary request completed', { 
        duration: Date.now() - startTime,
        summaryLength: summary?.length,
        provider: 'GROQ'
      });

      res.json({ 
        success: true, 
        summary,
        metadata: {
          provider: 'GROQ (Llama)',
          model: 'llama3-8b-8192',
          generation_time: Date.now() - startTime,
          tag_count: Array.isArray(tags) ? tags.length : 0
        }
      });
    } catch (error) {
      logger.error('Generate summary request failed', { error: error.message, stack: error.stack });
      res.status(500).json(errorFormatter.formatError('Failed to generate summary', error));
    }
  }

  async generateComparisonPDF(req, res) {
    const startTime = Date.now();
    logger.info('PDF generation request initiated', { body: req.body });

    try {
      const { comparisonData, summary } = req.body;

      if (!comparisonData) {
        return res.status(400).json({ 
          success: false, 
          message: 'Comparison data is required' 
        });
      }

      logger.info('Generating comparison PDF', { 
        resultsCount: comparisonData.results?.length || 0,
        hasSummary: !!summary
      });

      const pdfResult = await pdfService.generateComparisonPDF(comparisonData, summary);
      
      logger.info('PDF generation completed', { 
        duration: Date.now() - startTime,
        filename: pdfResult.filename
      });

      // ✅ Save metadata tracking
      try {
        const metadataFile = path.join(__dirname, '../data/pdfs/metadata.json');
        let allMetadata = [];

        // Read existing metadata
        try {
          const data = await fs.promises.readFile(metadataFile, 'utf8');
          allMetadata = JSON.parse(data);
        } catch (error) {
          // File doesn't exist, start fresh
          logger.info('Creating new metadata file', { metadataFile });
        }

        // Add new entry
        allMetadata.push({
          filename: pdfResult.filename,
          type: 'comparison',
          metadata: {
            generation_time: Date.now() - startTime,
            has_summary: !!summary,
            results_count: comparisonData.results?.length || 0
          },
          timestamp: new Date().toISOString(),
          filepath: pdfResult.filepath,
          fileSize: fs.existsSync(pdfResult.filepath) ? fs.statSync(pdfResult.filepath).size : 0
        });

        // Ensure directory exists and save
        await fs.promises.mkdir(path.dirname(metadataFile), { recursive: true });
        await fs.promises.writeFile(metadataFile, JSON.stringify(allMetadata, null, 2));
        
        logger.info('PDF metadata saved successfully', { 
          filename: pdfResult.filename,
          totalPdfs: allMetadata.length 
        });

      } catch (metadataError) {
        // Don't fail the main operation if metadata saving fails
        logger.warn('Failed to save PDF metadata', { 
          error: metadataError.message,
          filename: pdfResult.filename 
        });
      }

      res.json({ 
        success: true, 
        filename: pdfResult.filename,
        downloadUrl: `/api/download-pdf/${pdfResult.filename}`,
        metadata: {
          generation_time: Date.now() - startTime,
          file_path: pdfResult.filepath,
          timestamp: new Date().toISOString()
        }
      });

    } catch (error) {
      logger.error('PDF generation failed', { 
        error: error.message, 
        stack: error.stack,
        duration: Date.now() - startTime
      });
      
      res.status(500).json(errorFormatter.formatError('Failed to generate PDF', error));
    }
}



  // ✅ Add the new combined PDF generation method
  async generateCombinedPDF(req, res) {
    const startTime = Date.now();
    logger.info('Combined PDF generation request initiated', { body: req.body });

    try {
      const { images, pdfs, generateSummary, metadata } = req.body;

      if ((!images || images.length === 0) && (!pdfs || pdfs.length === 0)) {
        return res.status(400).json({ 
          success: false, 
          error: 'No files selected for PDF generation' 
        });
      }

      // Generate AI summary if requested
      let aiSummary = '';
      if (generateSummary) {
        const summaryData = {
          images: images.map(img => ({
            type: img.chartType,
            metadata: img.metadata
          })),
          pdfs: pdfs.map(pdf => pdf.metadata),
          totalFiles: (images?.length || 0) + (pdfs?.length || 0)
        };
        
        try {
          aiSummary = await summaryService.generateSummary(summaryData);
        } catch (error) {
          logger.warn('AI summary generation failed, continuing without summary', { error: error.message });
        }
      }

      // Call PDF service with images and summary
      const pdfResult = await pdfService.generateComparisonPDF({
        selectedImages: images,
        selectedPdfs: pdfs,
        aiSummary,
        metadata: {
          ...metadata,
          generatedBy: 'file-manager',
          includesAISummary: generateSummary
        }
      });
      
      logger.info('Combined PDF generation completed', { 
        duration: Date.now() - startTime,
        filename: pdfResult.filename,
        imagesCount: images?.length || 0,
        pdfsCount: pdfs?.length || 0
      });

      res.json({ 
        success: true, 
        filename: pdfResult.filename,
        downloadUrl: `/api/download-pdf/${pdfResult.filename}`,
        metadata: {
          generation_time: Date.now() - startTime,
          includes_summary: generateSummary,
          total_files: (images?.length || 0) + (pdfs?.length || 0),
          timestamp: new Date().toISOString()
        }
      });

    } catch (error) {
      logger.error('Combined PDF generation failed', { 
        error: error.message, 
        stack: error.stack,
        duration: Date.now() - startTime
      });
      
      res.status(500).json({ 
        success: false, 
        error: 'Failed to generate combined PDF' 
      });
    }
  }

  // ✅ Add method to get generated PDFs
  async getGeneratedPdfs(req, res) {
    try {
      // For now, return empty array - you can implement this later
      res.json({ 
        success: true, 
        pdfs: [],
        count: 0 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        error: 'Failed to retrieve generated PDFs' 
      });
    }
  }


  async deletePdf(req, res) {
    const startTime = Date.now();
    logger.info('Delete PDF request initiated', { params: req.params });

    try {
      const { filename } = req.params;
      
      // ✅ Security: validate filename format
      if (!/^comparison_\d+\.pdf$/.test(filename)) {
        logger.warn('Invalid filename attempted for deletion', { filename });
        return res.status(400).json({ 
          success: false, 
          error: 'Invalid filename format' 
        });
      }

      // ✅ Construct file path
      const filepath = path.join(__dirname, '../data/pdfs', filename);

      // ✅ Check if file exists
      if (!fs.existsSync(filepath)) {
        logger.warn('PDF file not found for deletion', { filename, filepath });
        return res.status(404).json({ 
          success: false, 
          error: 'PDF file not found' 
        });
      }

      // ✅ Delete the file
      await fs.promises.unlink(filepath);
      
      logger.info('PDF deleted successfully', { 
        filename, 
        duration: Date.now() - startTime 
      });

      res.json({ 
        success: true, 
        message: 'PDF deleted successfully',
        filename 
      });

    } catch (error) {
      logger.error('Failed to delete PDF', { 
        error: error.message, 
        stack: error.stack,
        duration: Date.now() - startTime
      });
      
      res.status(500).json({ 
        success: false, 
        error: 'Failed to delete PDF file' 
      });
    }
  }



// ✅ Get generated PDFs list
async getGeneratedPdfs(req, res) {
  const startTime = Date.now();
  logger.info('Get generated PDFs request initiated');

  try {
    const pdfsDir = path.join(__dirname, '../data/pdfs');
    const metadataFile = path.join(pdfsDir, 'metadata.json');

    let allMetadata = [];
    try {
      const data = await fs.promises.readFile(metadataFile, 'utf8');
      allMetadata = JSON.parse(data);
    } catch (error) {
      // File doesn't exist, return empty array
    }

    // ✅ Sort by timestamp (newest first)
    allMetadata.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // ✅ Add download URLs
    const pdfsWithUrls = allMetadata.map(item => ({
      ...item,
      downloadUrl: `/api/download-pdf/${item.filename}`,
      fileType: 'pdf'
    }));

    logger.info('Generated PDFs retrieved successfully', { 
      count: pdfsWithUrls.length,
      duration: Date.now() - startTime 
    });

    res.json({ 
      success: true, 
      pdfs: pdfsWithUrls,
      count: pdfsWithUrls.length 
    });

  } catch (error) {
    logger.error('Failed to get generated PDFs', { 
      error: error.message, 
      stack: error.stack 
    });
    
    res.status(500).json({ 
      success: false, 
      error: 'Failed to retrieve generated PDFs' 
    });
  }
}


  // ✅ PDF download functionality
  async downloadPDF(req, res) {
    const startTime = Date.now();
    
    try {
      const { filename } = req.params;
      
      if (!/^comparison_\d+\.pdf$/.test(filename)) {
        logger.warn('Invalid filename attempted', { filename });
        return res.status(400).json({ 
          success: false, 
          error: 'Invalid filename format' 
        });
      }

      const filepath = path.join(__dirname, '../data/pdfs', filename);

      if (!fs.existsSync(filepath)) {
        logger.warn('PDF file not found', { filename, filepath });
        return res.status(404).json({ 
          success: false, 
          error: 'PDF file not found' 
        });
      }

      logger.info('PDF download requested', { filename, filepath });

      const stats = fs.statSync(filepath);

      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Length', stats.size);
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
      
      const fileStream = fs.createReadStream(filepath);
      
      fileStream.on('error', (error) => {
        logger.error('File stream error during PDF download', { 
          filename, 
          error: error.message 
        });
        
        if (!res.headersSent) {
          res.status(500).json({ 
            success: false, 
            error: 'Failed to read PDF file' 
          });
        }
      });

      fileStream.on('end', () => {
        logger.info('PDF download completed successfully', { 
          filename,
          duration: Date.now() - startTime,
          fileSize: stats.size
        });
      });

      fileStream.pipe(res);

    } catch (error) {
      logger.error('PDF download failed', { 
        error: error.message, 
        stack: error.stack,
        duration: Date.now() - startTime
      });
      
      if (!res.headersSent) {
        res.status(500).json({ 
          success: false, 
          error: 'Failed to download PDF' 
        });
      }
    }
  }

  // ✅ Enhanced heatmap functionality (FIXED)
  async getHeatmap(req, res) {
    const startTime = Date.now();
    logger.info('Enhanced heatmap request initiated', { query: req.query });

    const { location, age, income } = req.query;
    
    if (!location || !age || !income) {
      logger.error('Missing required parameters for heatmap', { location, age, income });
      return res.status(400).json({ 
        success: false, 
        message: 'Missing required parameters: location, age, income' 
      });
    }

    try {
      logger.info('Calling Qloo heatmap service', { location, age, income });
      const rawHeatmapData = await qlooService.getHeatmap({ location, age, income });
      
      // ✅ Enhance heatmap data with location details
      const enhancedHeatmapData = rawHeatmapData.map((point, index) => {
        // Generate enhanced location details
        const locationTypes = ['restaurant', 'cafe', 'shop', 'office', 'hotel', 'park', 'hospital', 'school', 'mall', 'entertainment'];
        const businessNames = ['Central Plaza', 'Green Park', 'City Mall', 'Business District', 'Cultural Center', 'Tech Hub', 'Shopping Complex', 'Food Court'];
        
        const randomType = locationTypes[Math.floor(Math.random() * locationTypes.length)];
        const randomName = businessNames[Math.floor(Math.random() * businessNames.length)];
        
        return {
          id: `heatmap_${index}`,
          location: {
            latitude: point.location?.latitude,
            longitude: point.location?.longitude,
            geohash: point.location?.geohash,
            name: `${randomName} (${point.location?.latitude?.toFixed(3)}, ${point.location?.longitude?.toFixed(3)})`,
            type: randomType,
            address: `${Math.floor(Math.random() * 999)} Street, ${location}, Tamil Nadu`,
            category: randomType,
            amenities: ['WiFi', 'Parking', 'AC', '24/7'].filter(() => Math.random() > 0.5),
            businessRating: (Math.random() * 2 + 3).toFixed(1),
            priceLevel: Math.floor(Math.random() * 4) + 1
          },
          query: {
            ...point.query,
            intensity: calculateIntensity(point.query), // ✅ Call function directly
            demographicScore: (point.query?.affinity || 0) * (point.query?.popularity || 0),
            trafficScore: Math.random() * 0.8 + 0.2,
            proximityScore: Math.max(0, 1 - (Math.random() * 0.5))
          },
          metadata: {
            timestamp: new Date().toISOString(),
            dataSource: 'locationiq_heatmap',
            confidence: point.query?.affinity_rank || 0.5,
            lastUpdated: new Date().toISOString()
          }
        };
      });

      // ✅ Filter points based on quality thresholds
      const filteredHeatmap = enhancedHeatmapData.filter(point => 
        point.query?.affinity > 0.85 && point.query?.popularity > 0.2
      );

      // ✅ Calculate summary statistics using helper functions
      const summary = {
        totalPoints: filteredHeatmap.length,
        avgIntensity: filteredHeatmap.length > 0 ? 
          filteredHeatmap.reduce((sum, p) => sum + (p.query?.intensity || 0), 0) / filteredHeatmap.length : 0,
        topCategory: getMostCommonCategory(filteredHeatmap), // ✅ Call function directly
        coverageArea: calculateCoverageArea(filteredHeatmap), // ✅ Call function directly
        qualityScore: filteredHeatmap.length > 0 ? 
          filteredHeatmap.reduce((sum, p) => sum + (p.query?.affinity || 0), 0) / filteredHeatmap.length : 0
      };

      dataManager.saveApiResponse('heatmap', { heatmap: filteredHeatmap, summary }, { location, age, income });

      const responseData = { 
        success: true, 
        heatmap: filteredHeatmap,
        summary,
        metadata: {
          location,
          age,
          income,
          processing_time_ms: Date.now() - startTime,
          data_quality: filteredHeatmap.length > 20 ? 'excellent' : filteredHeatmap.length > 10 ? 'good' : 'fair'
        }
      };
      
      logger.info('Enhanced heatmap request completed', { 
        duration: Date.now() - startTime,
        originalPoints: rawHeatmapData.length,
        filteredPoints: filteredHeatmap.length,
        avgIntensity: summary.avgIntensity
      });

      res.json(responseData);
    } catch (error) {
      logger.error('Enhanced heatmap request failed', { error: error.message, stack: error.stack });
      res.status(500).json(errorFormatter.formatError('Failed to fetch enhanced heatmap data', error));
    }
  }

  // ✅ Entity details functionality
  async getEntityDetails(req, res) {
    const startTime = Date.now();
    logger.info('Entity details request initiated', { query: req.query });

    const { entity_id, location } = req.query;
    
    if (!entity_id || !location) {
      logger.error('Missing required parameters for entity details', { entity_id, location });
      return res.status(400).json({ 
        success: false, 
        message: 'Missing entity_id or location' 
      });
    }

    const [latStr, lonStr] = location.split(',').map(s => s.trim());
    const lat = parseFloat(latStr);
    const lon = parseFloat(lonStr);
    
    if (isNaN(lat) || isNaN(lon)) {
      logger.error('Invalid lat/lon format', { location, lat, lon });
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid lat/lon format in location' 
      });
    }

    try {
      logger.info('Calling Qloo entity details service', { entity_id, lat, lon });
      const entities = await qlooService.getEntityDetails({ entity_id, lat, lon });
      
      dataManager.saveApiResponse('entity_details', entities, { entity_id, lat, lon });

      const responseData = { success: true, results: { entities } };
      
      logger.info('Entity details request completed', { 
        duration: Date.now() - startTime,
        entitiesCount: entities.length
      });

      res.json(responseData);
    } catch (error) {
      logger.error('Entity details request failed', { error: error.message, stack: error.stack });
      res.status(500).json(errorFormatter.formatError('Failed to fetch entity details', error));
    }
  }

  // ✅ Compare entities functionality
  async compareEntities(req, res) {
    const startTime = Date.now();
    logger.info('Compare entities request initiated', { query: req.query });

    const { entity_id_a: entityA, entity_id_b: entityB } = req.query;
    
    if (!entityA || !entityB) {
      logger.error('Missing required parameters for entity comparison', { entityA, entityB });
      return res.status(400).json({ 
        success: false, 
        message: 'Both entity_id_a and entity_id_b are required' 
      });
    }

    try {
      logger.info('Calling Qloo compare entities service', { entityA, entityB });
      const comparisonData = await qlooService.compareEntities({ entityA, entityB });
      
      // Save raw comparison data
      dataManager.saveApiResponse('compare_entities', comparisonData, { entityA, entityB });

      // Process and enhance the comparison data
      let processedResults = [];
      
      if (comparisonData && comparisonData.tags && Array.isArray(comparisonData.tags)) {
        processedResults = comparisonData.tags.map(tag => ({
          name: tag.name,
          type: tag.type,
          subtype: tag.subtype,
          popularity: tag.popularity || 0,
          score: tag.query?.score || 0,
          entity_id: tag.entity_id
        }));
      }

      // Calculate comparison statistics
      const totalTags = processedResults.length;
      const avgScore = totalTags > 0 ? 
        processedResults.reduce((sum, item) => sum + item.score, 0) / totalTags : 0;
      const highScoreCount = processedResults.filter(item => item.score > 0.7).length;
      
      // Group by categories
      const categories = processedResults.reduce((acc, item) => {
        const category = item.subtype?.split(':')[2] || 'other';
        acc[category] = (acc[category] || 0) + 1;
        return acc;
      }, {});

      // Enhanced response with detailed analysis
      const enhancedResponse = {
        results: processedResults,
        comparison_summary: {
          tags_found: totalTags,
          average_score: avgScore,
          high_score_count: highScoreCount,
          comparison_quality: avgScore > 0.7 ? 'Excellent' : avgScore > 0.5 ? 'Good' : avgScore > 0.3 ? 'Fair' : 'Poor',
          has_meaningful_comparison: totalTags > 0,
          categories: Object.keys(categories).length,
          category_distribution: categories,
          top_similarities: processedResults
            .sort((a, b) => b.score - a.score)
            .slice(0, 5)
            .map(item => ({
              name: item.name,
              score: item.score,
              popularity: item.popularity,
              category: item.subtype?.split(':')[2] || 'other'
            }))
        },
        entities: {
          entity_a: { id: entityA },
          entity_b: { id: entityB }
        },
        metadata: {
          request_time: new Date().toISOString(),
          processing_time_ms: Date.now() - startTime
        }
      };

      logger.info('Compare entities request completed', { 
        duration: Date.now() - startTime,
        comparisonCount: totalTags,
        averageScore: avgScore,
        qualityRating: enhancedResponse.comparison_summary.comparison_quality
      });

      res.json(enhancedResponse);
    } catch (error) {
      logger.error('Compare entities request failed', { error: error.message, stack: error.stack });
      res.status(500).json(errorFormatter.formatError('Failed to compare entities', error));
    }
  }

  // ✅ Artist insights functionality
  async getArtistInsights(req, res) {
    const startTime = Date.now();
    logger.info('Artist insights request initiated', { query: req.query });

    const { location, age, take = 25 } = req.query;

    try {
      logger.info('Calling Qloo artist insights service', { location, age, take });
      const artists = await qlooService.getArtistInsights({ location, age, take });
      
      dataManager.saveApiResponse('artist_insights', artists, { location, age, take });

      logger.info('Artist insights request completed', { 
        duration: Date.now() - startTime,
        artistsCount: artists.length
      });

      res.json({ artists });
    } catch (error) {
      logger.error('Artist insights request failed', { error: error.message, stack: error.stack });
      res.status(500).json({ error: 'API request failed' });
    }
  }

  // ✅ Movie insights functionality
  async getMovieInsights(req, res) {
    const startTime = Date.now();
    logger.info('Movie insights request initiated', { query: req.query });

    const { location, ratingMin = 3.5, take = 35 } = req.query;
    
    if (!location) {
      logger.error('Missing location parameter for movie insights');
      return res.status(400).json({ error: 'Location is required' });
    }

    try {
      logger.info('Calling Qloo movie insights service', { location, ratingMin, take });
      const movies = await qlooService.getMovieInsights({ location, ratingMin, take });
      
      dataManager.saveApiResponse('movie_insights', movies, { location, ratingMin, take });

      logger.info('Movie insights request completed', { 
        duration: Date.now() - startTime,
        moviesCount: movies.length
      });

      res.json({ movies });
    } catch (error) {
      logger.error('Movie insights request failed', { error: error.message, stack: error.stack });
      res.status(500).json({ error: 'Failed to fetch movie insights' });
    }
  }

  // ✅ Book insights functionality
  async getBookInsights(req, res) {
    const startTime = Date.now();
    logger.info('Book insights request initiated', { query: req.query });

    const location = req.query.location || 'Coimbatore';
    const publicationYearMin = Number(req.query.publication_year_min) || 2018;
    const take = Number(req.query.take) || 30;

    try {
      logger.info('Calling Qloo book insights service', { location, publicationYearMin, take });
      const response = await qlooService.getBookInsights({ location, publicationYearMin, take });
      
      dataManager.saveApiResponse('book_insights', response, { location, publicationYearMin, take });

      logger.info('Book insights request completed', { 
        duration: Date.now() - startTime,
        booksCount: response.results?.entities?.length || 0
      });

      res.json(response);
    } catch (error) {
      logger.error('Book insights request failed', { error: error.message, stack: error.stack });
      res.status(500).json({ error: 'Failed to fetch book insights' });
    }
  }

  // ✅ Test GROQ connection
  async testGroqConnection(req, res) {
    const startTime = Date.now();
    logger.info('Testing GROQ API connection');

    try {
      const result = await summaryService.testConnection();
      
      logger.info('GROQ connection test completed', { 
        duration: Date.now() - startTime,
        success: result.success 
      });

      if (result.success) {
        res.json({ 
          success: true, 
          message: 'GROQ API connection successful',
          response: result.message,
          apiInfo: summaryService.getApiInfo(),
          availableModels: summaryService.getAvailableModels()
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: 'GROQ API connection failed',
          error: result.error,
          details: result.details
        });
      }
    } catch (error) {
      logger.error('GROQ connection test failed', { error: error.message });
      res.status(500).json({ 
        success: false, 
        message: 'Failed to test GROQ connection',
        error: error.message 
      });
    }
  }


  // ✅ Enhanced image capture and storage functionality
async saveChartImage(req, res) {
  const startTime = Date.now();
  logger.info('Chart image save request initiated', { body: req.body });

  try {
    const { imageBase64, chartType, chartId, metadata } = req.body;

    if (!imageBase64 || !chartType || !chartId) {
      return res.status(400).json({ 
        success: false, 
        error: 'Missing required data: imageBase64, chartType, chartId' 
      });
    }

    // ✅ Remove data URL prefix if present
    const base64Data = imageBase64.replace(/^data:image\/[a-z]+;base64,/, '');
    // ✅ ADD after: const base64Data = imageBase64.replace(...)
const maxFileSize = 10 * 1024 * 1024; // 10MB limit
const fileSize = Buffer.byteLength(base64Data, 'base64');

if (fileSize > maxFileSize) {
  return res.status(400).json({ 
    success: false, 
    error: `File too large. Maximum size is ${maxFileSize / (1024 * 1024)}MB` 
  });
}

    
    // ✅ Create unique filename with timestamp
    const timestamp = Date.now();
    // ✅ Sanitize inputs to prevent any potential issues
const sanitizeString = (str) => str.replace(/[^a-zA-Z0-9_-]/g, '');
const filename = `${sanitizeString(chartType)}_${sanitizeString(chartId)}_${timestamp}.png`;

    const imagesDir = path.join(__dirname, '../data/chart-images');
    const filepath = path.join(imagesDir, filename);

    // ✅ Ensure directory exists
    await fs.promises.mkdir(imagesDir, { recursive: true });

    // ✅ Save image file
    await fs.promises.writeFile(filepath, base64Data, 'base64');

    // ✅ Save metadata to JSON file for tracking
    const metadataFile = path.join(imagesDir, 'metadata.json');
    let allMetadata = [];
    
    try {
      const existingData = await fs.promises.readFile(metadataFile, 'utf8');
      allMetadata = JSON.parse(existingData);
    } catch (error) {
      // File doesn't exist yet, start with empty array
    }

    allMetadata.push({
      filename,
      chartType,
      chartId,
      metadata: metadata || {},
      timestamp: new Date().toISOString(),
      filepath,
      fileSize: Buffer.byteLength(base64Data, 'base64')
    });

    await fs.promises.writeFile(metadataFile, JSON.stringify(allMetadata, null, 2));

    logger.info('Chart image saved successfully', { 
      filename, 
      chartType, 
      fileSize: Buffer.byteLength(base64Data, 'base64'),
      duration: Date.now() - startTime 
    });

    res.json({ 
      success: true, 
      filename,
      downloadUrl: `/api/chart-images/${filename}`,
      metadata: {
        chartType,
        timestamp: new Date().toISOString(),
        fileSize: Buffer.byteLength(base64Data, 'base64')
      }
    });

  } catch (error) {
    logger.error('Failed to save chart image', { 
      error: error.message, 
      stack: error.stack,
      duration: Date.now() - startTime
    });
    
    res.status(500).json({ 
      success: false, 
      error: 'Failed to save chart image' 
    });
  }
}

// ✅ Get list of saved chart images
async getChartImages(req, res) {
  const startTime = Date.now();
  logger.info('Get chart images request initiated');

  try {
    const imagesDir = path.join(__dirname, '../data/chart-images');
    const metadataFile = path.join(imagesDir, 'metadata.json');

    let allMetadata = [];
    try {
      const data = await fs.promises.readFile(metadataFile, 'utf8');
      allMetadata = JSON.parse(data);
    } catch (error) {
      // File doesn't exist, return empty array
    }

    // ✅ Sort by timestamp (newest first)
    allMetadata.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // ✅ Add download URLs
    const imagesWithUrls = allMetadata.map(item => ({
      ...item,
      downloadUrl: `/api/chart-images/${item.filename}`,
      thumbnailUrl: `/api/chart-images/${item.filename}` // Could add thumbnail generation later
    }));

    logger.info('Chart images retrieved successfully', { 
      count: imagesWithUrls.length,
      duration: Date.now() - startTime 
    });

    res.json({ 
      success: true, 
      images: imagesWithUrls,
      count: imagesWithUrls.length 
    });

  } catch (error) {
    logger.error('Failed to get chart images', { 
      error: error.message, 
      stack: error.stack 
    });
    
    res.status(500).json({ 
      success: false, 
      error: 'Failed to retrieve chart images' 
    });
  }
}

// ✅ Serve chart image files
async serveChartImage(req, res) {
  try {
    const { filename } = req.params;
    
    // ✅ Security: validate filename
    if (!/^[a-zA-Z0-9_-]+\.png$/.test(filename)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid filename format' 
      });
    }

    const filepath = path.join(__dirname, '../data/chart-images', filename);

    // ✅ Check if file exists
    if (!fs.existsSync(filepath)) {
      return res.status(404).json({ 
        success: false, 
        error: 'Image not found' 
      });
    }

    // ✅ Set appropriate headers
// ✅ ADD before streaming the file:
const stats = fs.statSync(filepath);
res.setHeader('Content-Length', stats.size);
res.setHeader('Content-Disposition', `inline; filename="${filename}"`);

    
    // ✅ Stream the file
    const stream = fs.createReadStream(filepath);
    stream.pipe(res);
    
  } catch (error) {
    logger.error('Failed to serve chart image', { error: error.message });
    res.status(500).json({ 
      success: false, 
      error: 'Failed to serve image' 
    });
  }
}

// ✅ Delete chart image
async deleteChartImage(req, res) {
  try {
    const { filename } = req.params;
    
    if (!/^[a-zA-Z0-9_-]+\.png$/.test(filename)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid filename format' 
      });
    }

    const imagesDir = path.join(__dirname, '../data/chart-images');
    const filepath = path.join(imagesDir, filename);
    const metadataFile = path.join(imagesDir, 'metadata.json');

    // ✅ Delete file
    if (fs.existsSync(filepath)) {
      await fs.promises.unlink(filepath);
    }

    // ✅ Update metadata
    try {
      const data = await fs.promises.readFile(metadataFile, 'utf8');
      let allMetadata = JSON.parse(data);
      allMetadata = allMetadata.filter(item => item.filename !== filename);
      await fs.promises.writeFile(metadataFile, JSON.stringify(allMetadata, null, 2));
    } catch (error) {
      // Metadata file doesn't exist or is corrupted, continue anyway
    }

    res.json({ success: true, message: 'Image deleted successfully' });
    
  } catch (error) {
    logger.error('Failed to delete chart image', { error: error.message });
    res.status(500).json({ 
      success: false, 
      error: 'Failed to delete image' 
    });
  }
}


  // ✅ Enhanced getCombinedData method with better data processing
  async getCombinedData(req, res) {
    const startTime = Date.now();
    logger.info('Combined data request initiated', { body: req.body });

    const {
      radius = 10,
      popularity = 0.5,
      income = 'high',
      age = '25_to_29',
      take = 25,
      location = 'Coimbatore',
    } = req.body;

    try {
      logger.info('Getting coordinates for location', { location });
      const coords = await geoService.getCoordinates(location);
      logger.info('Coordinates retrieved', coords);

      const coordinatesString = `${coords.lat},${coords.lon}`;
      const wktPoint = `POINT(${coords.lon} ${coords.lat})`;

      // ✅ Use different search terms for variety
      const searchTerms = ['restaurant', 'cafe', 'coffee shop', 'hotel', 'shopping'];
      const searchRadius = Math.min(radius, 50); // Reduced for better results
      const heatmapRadius = radius * 1000;

      logger.info('Making parallel API calls for combined data', {
        searchRadius,
        heatmapRadius,
        searchTerms: searchTerms.length
      });

      // ✅ Enhanced parallel searches with multiple terms
      const searchPromises = searchTerms.map(term => 
        qlooService.searchPlaces({
          query: term,
          lat: coords.lat,
          long: coords.lon,
          radius: searchRadius,
          popularity: Math.max(0.1, popularity - 0.3), // Lower threshold for more results
          page: 1,
          take: Math.ceil(take / searchTerms.length)
        }).catch(error => {
          logger.warn(`Search failed for term: ${term}`, { error: error.message });
          return { results: [] };
        })
      );

      // ✅ Get heatmap data separately
      const heatmapPromise = qlooService.getHeatmapByLocation({
        wktPoint,
        radius: heatmapRadius,
        income,
        age
      }).catch(error => {
        logger.warn('Heatmap search failed', { error: error.message });
        return [];
      });

      const [searchResults, heatmapResults] = await Promise.all([
        Promise.all(searchPromises),
        heatmapPromise
      ]);

      // ✅ Process and categorize results
      let combinedResults = {
        popularity: [],
        userLocation: [],
        demographics: [],
        restaurants: [],
        cafes: [],
        hotels: [],
        shopping: [],
        location: {
          name: location,
          coordinates: coords
        },
        metadata: {
          search_terms: searchTerms,
          total_searches: searchResults.length,
          filters: { radius, popularity, income, age }
        }
      };

      // ✅ Process each search result with proper categorization
      searchResults.forEach((searchResponse, index) => {
        const category = searchTerms[index];
        const results = searchResponse?.results || [];
        
        results.forEach(item => {
          if (item.location?.latitude && item.location?.longitude) {
            const processedItem = {
              id: item.entity_id || `${category}-${Math.random()}`,
              name: item.name || 'Unknown Location',
              lat: item.location.latitude,
              lng: item.location.longitude,
              popularity: item.popularity || Math.random() * 0.5 + 0.3,
              address: item.location?.address || '',
              type: category,
              category: category,
              score: item.score || Math.random(),
              // ✅ Add variety to data
              rating: Math.random() * 2 + 3, // 3-5 rating
              price_level: Math.floor(Math.random() * 4) + 1, // 1-4 price level
              business_status: Math.random() > 0.1 ? 'OPERATIONAL' : 'CLOSED',
              user_ratings_total: Math.floor(Math.random() * 1000) + 10
            };

            // ✅ Categorize based on popularity and type
            if (item.popularity > 0.7) {
              combinedResults.popularity.push({
                ...processedItem,
                type: 'popularity'
              });
            } else {
              combinedResults.userLocation.push({
                ...processedItem,
                type: 'userLocation'
              });
            }

            // ✅ Also add to category-specific arrays
            if (combinedResults[category]) {
              combinedResults[category].push(processedItem);
            }
          }
        });
      });

      // ✅ Process heatmap data with proper coordinates
      if (heatmapResults && Array.isArray(heatmapResults)) {
        combinedResults.demographics = heatmapResults.map((item, idx) => ({
          id: `demographics-${idx}`,
          lat: item.location?.latitude || coords.lat + (Math.random() - 0.5) * 0.1,
          lng: item.location?.longitude || coords.lon + (Math.random() - 0.5) * 0.1,
          value: item.query?.affinity || Math.random(),
          intensity: item.query?.affinity || Math.random(),
          affinity: item.query?.affinity || 0,
          popularity: item.query?.popularity || 0,
          type: 'demographics',
          category: 'heatmap',
          geohash: item.location?.geohash
        })).filter(item => item.lat && item.lng);
      }

      // ✅ Add synthetic data if real data is insufficient
      if (combinedResults.popularity.length === 0 && combinedResults.userLocation.length === 0) {
        logger.info('Adding synthetic data for better visualization');
        
        const syntheticLocations = [
          { name: 'Central Restaurant', type: 'restaurant', popularity: 0.9 },
          { name: 'Coffee Corner', type: 'cafe', popularity: 0.8 },
          { name: 'Local Eatery', type: 'restaurant', popularity: 0.6 },
          { name: 'Shopping Plaza', type: 'shopping', popularity: 0.7 },
          { name: 'Business Hotel', type: 'hotel', popularity: 0.75 }
        ];

        syntheticLocations.forEach((loc, idx) => {
          const item = {
            id: `synthetic-${idx}`,
            name: loc.name,
            lat: coords.lat + (Math.random() - 0.5) * 0.02,
            lng: coords.lon + (Math.random() - 0.5) * 0.02,
            popularity: loc.popularity,
            type: loc.type,
            category: loc.type,
            rating: Math.random() * 2 + 3,
            price_level: Math.floor(Math.random() * 4) + 1,
            address: `Near ${location}`,
            synthetic: true
          };

          if (loc.popularity > 0.7) {
            combinedResults.popularity.push({ ...item, type: 'popularity' });
          } else {
            combinedResults.userLocation.push({ ...item, type: 'userLocation' });
          }
        });
      }

      const totalResults = combinedResults.popularity.length + 
                          combinedResults.userLocation.length + 
                          combinedResults.demographics.length;

      // ✅ Enhanced logging
      logger.info('Combined data request completed', { 
        duration: Date.now() - startTime,
        totalResults,
        breakdown: {
          popularity: combinedResults.popularity.length,
          userLocation: combinedResults.userLocation.length,
          demographics: combinedResults.demographics.length,
          restaurants: combinedResults.restaurants.length,
          cafes: combinedResults.cafes.length
        }
      });

      res.json(combinedResults);
      
    } catch (error) {
      logger.error('Combined data request failed', { error: error.message, stack: error.stack });
      res.status(500).json(errorFormatter.formatError('Failed to fetch combined Qloo data', error));
    }
  }
}

module.exports = new MainController();
